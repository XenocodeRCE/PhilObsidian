/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => BoostLinkPlugin
});
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  triggerString: "b[",
  yamlFrontMatterBoostTag: "boost",
  showScores: true,
  useObsidianFuzzyMatching: false,
  saveMostRecentSelections: true,
  mostRecentSelections: [],
  apiVersion: 2
};
var deduplicateLinks = (links) => {
  return links.reduce((deduplicatedLinks, current) => {
    if (!deduplicatedLinks.some((x) => x.alias == current.alias && x.path == current.path)) {
      deduplicatedLinks.push(current);
    }
    return deduplicatedLinks;
  }, []);
};
var getBoostedSuggestions = (plugin, files, filterString) => {
  const searchCallback = (0, import_obsidian.prepareFuzzySearch)(filterString);
  const queryWords = filterString.toLowerCase().split(/\s{1,}/);
  const resolvedLinks = Object.values(plugin.app.metadataCache.resolvedLinks);
  const backlinkCounts = getBackLinkCounts(resolvedLinks);
  let boostlinksGathered = files.map((file) => {
    var _a;
    const frontMatter = (_a = plugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    const boost = (frontMatter == null ? void 0 : frontMatter.boost) && Number.isInteger(frontMatter.boost) ? frontMatter.boost : 0;
    const linkCount = backlinkCounts[file.path] || 0;
    const finalLinkCount = linkCount + boost;
    let aliases = (frontMatter == null ? void 0 : frontMatter.alias) || (frontMatter == null ? void 0 : frontMatter.aliases) || [];
    if (!Array.isArray(aliases)) {
      aliases = aliases != null ? [aliases] : [];
    }
    aliases = aliases.filter((a) => a);
    let output = [
      ...Array.isArray(aliases) ? aliases : [aliases],
      file.basename
    ].map((alias) => {
      if (alias === void 0 || alias === null) {
        return null;
      }
      let componentMatchScore = null;
      let finalMatchScore = 0;
      if (plugin.settings.useObsidianFuzzyMatching) {
        const fuzzyMatchOutput = searchCallback(alias);
        if (!fuzzyMatchOutput) {
          return null;
        }
        componentMatchScore = -1 * Math.round(fuzzyMatchOutput.score * 100) / 100;
        finalMatchScore = -1 * fuzzyMatchOutput.score * finalLinkCount;
      } else {
        if (filterString) {
          const isMatch = queryWords.every((word) => {
            return alias.toLowerCase().contains(word) || file.path.toLowerCase().contains(word);
          });
          if (!isMatch) {
            return null;
          }
          finalMatchScore = linkCount + boost;
        }
      }
      return {
        alias: `${alias}`,
        matchScore: finalMatchScore,
        path: `${file.path}`,
        originTFile: file,
        isAlias: alias !== file.basename,
        extension: file.path.split(".").pop(),
        linkCount: finalLinkCount,
        linkCountDescription: `${Math.round(finalMatchScore * 100) / 100}: ${componentMatchScore ? "Search score of " + componentMatchScore + " * " : ""}${componentMatchScore ? "(" : ""}${linkCount} links + ${boost ? "boost of " + boost : "no boost"}${componentMatchScore ? ")" : ""}`
      };
    }).flat();
    return output;
  }).filter((a) => a.length).flat().filter((r) => r !== void 0 && r !== null);
  boostlinksGathered = deduplicateLinks(boostlinksGathered);
  return boostlinksGathered.sort((a, b) => b.matchScore - a.matchScore);
};
var renderSuggestionObject = (suggestion, el, showScores) => {
  const suggesterEl = el.createDiv({ cls: "boostlink-suggester-el" });
  if (suggestion.isAlias) {
    const aliasEl = suggesterEl.createSpan();
    aliasEl.setText("\u293F");
    aliasEl.addClass("boostlink-is-alias");
  }
  const suggestionTextEl = suggesterEl.createDiv({
    cls: "boostlink-suggestion-text"
  });
  suggestionTextEl.createDiv({ cls: "boostlink-alias" }).setText(suggestion.alias);
  suggestionTextEl.createDiv({ cls: "boostlink-item" }).setText(suggestion.path);
  if (showScores) {
    suggestionTextEl.createDiv({ cls: "boostlink-count" }).setText(`${suggestion.linkCount !== null ? "Score: " : ""}${suggestion.linkCountDescription}`);
  }
};
var getBackLinkCounts = (cachedLinkCounts) => cachedLinkCounts.reduce((result, fileLinkCounts) => {
  for (const key in fileLinkCounts) {
    result[key] = (result[key] || 0) + fileLinkCounts[key];
  }
  return result;
}, {});
var BoostLinkPlugin = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.registerEditorSuggest(new BoostLinkEditorSuggester(this, this.settings));
      this.addCommand({
        id: "add-file-link",
        icon: "link",
        name: "Trigger link",
        editorCallback: (editor, view) => {
          editor.replaceSelection(this.settings.triggerString);
        }
      });
      this.addSettingTab(new BoostLinkSettingsTab(this.app, this));
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
};
var escapeRegExp = (str) => {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};
var BoostLinkEditorSuggester = class extends import_obsidian.EditorSuggest {
  constructor(plugin, settings) {
    super(plugin.app);
    this.plugin = plugin;
    this.settings = settings;
    this.triggerString = this.plugin.settings.triggerString;
  }
  onTrigger(cursor, editor, file) {
    var _a, _b;
    const line = editor.getLine(cursor.line);
    const subString = line.substring(0, cursor.ch);
    const match = (_a = subString.match(new RegExp(escapeRegExp(this.triggerString)))) == null ? void 0 : _a.first();
    const triggerStringClosingBrackets = (_b = this.triggerString.match(/\[{1,}$/)) == null ? void 0 : _b.first();
    if (match) {
      return {
        start: {
          ch: subString.lastIndexOf(match),
          line: cursor.line
        },
        end: {
          line: cursor.line,
          ch: triggerStringClosingBrackets && editor.getLine(cursor.line).length > cursor.ch && editor.getRange(cursor, {
            line: cursor.line,
            ch: cursor.ch + 1
          }) === "]".repeat(triggerStringClosingBrackets.length) ? cursor.ch + 1 : cursor.ch
        },
        query: subString.substring(subString.lastIndexOf(match) + this.triggerString.length, subString.length)
      };
    }
  }
  getSuggestions(context) {
    var _a;
    if (context.query === "" && ((_a = this.plugin.settings) == null ? void 0 : _a.mostRecentSelections.length) > 0) {
      const recentLinks = this.plugin.settings.mostRecentSelections.map((selection) => {
        if (!selection.path || !selection.alias || !this.plugin.app.vault.adapter.exists(selection.path)) {
          return null;
        }
        const tfile = this.plugin.app.metadataCache.getFirstLinkpathDest(selection.path, "");
        if (!tfile) {
          return null;
        }
        return {
          alias: `${selection.alias}`,
          path: `${selection.path}`,
          originTFile: tfile,
          isAlias: true,
          extension: selection.path.split(".").pop(),
          linkCount: null,
          linkCountDescription: `(Recently used)`
        };
      }).filter((e) => e !== null);
      return deduplicateLinks(recentLinks);
    }
    return getBoostedSuggestions(this.plugin, this.plugin.app.vault.getFiles(), context.query);
  }
  renderSuggestion(suggestion, el) {
    renderSuggestionObject(suggestion, el, this.plugin.settings.showScores);
  }
  selectSuggestion(suggestion) {
    return __async(this, null, function* () {
      var _a;
      if (this.context) {
        const file = this.plugin.app.metadataCache.getFirstLinkpathDest(suggestion.path, suggestion.originTFile.path);
        if (file) {
          const markdownLink = this.plugin.app.fileManager.generateMarkdownLink(file, this.context.file.path, "", suggestion.alias).replace(/^\!/, "");
          const editor = this.context.editor;
          editor.replaceRange(markdownLink, this.context.start, this.context.end);
          const { ch, line } = this.context.start;
          editor.setCursor({ line, ch: ch + markdownLink.length });
          if ((_a = this.plugin) == null ? void 0 : _a.settings.saveMostRecentSelections) {
            this.plugin.settings.mostRecentSelections = [{ alias: suggestion.alias, path: suggestion.path }, ...(this.plugin.settings.mostRecentSelections || []).slice(0, 10)];
            yield this.plugin.saveSettings();
          }
        }
      }
    });
  }
};
var BoostLinkSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Boost Link Suggestions" });
    new import_obsidian.Setting(containerEl).setName("Trigger string").setDesc('The string to trigger suggestions. Changing this setting requires reloading Obsidian. Triggering may not work if this string conflicts with an existing trigger (e.g., "[[").').addText((text) => text.setValue(this.plugin.settings.triggerString || DEFAULT_SETTINGS.triggerString).setPlaceholder(DEFAULT_SETTINGS.triggerString).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.triggerString = value || DEFAULT_SETTINGS.triggerString;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("YAML front-matter boost tag").setDesc("The YAML front-matter tag used to indicate link boost values.").addText((text) => text.setValue(this.plugin.settings.yamlFrontMatterBoostTag || DEFAULT_SETTINGS.yamlFrontMatterBoostTag).setPlaceholder(DEFAULT_SETTINGS.yamlFrontMatterBoostTag).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.yamlFrontMatterBoostTag = value || DEFAULT_SETTINGS.yamlFrontMatterBoostTag;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Show scores").setDesc("Show scores when displaying suggestions.").addToggle((toggle) => toggle.setValue(this.plugin.settings.showScores).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.showScores = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Use Obsidian fuzzy matching").setDesc("When searching for suggestions, use Obsidian's built-in fuzzy matching. (If turned off, searching is less fuzzy.)").addToggle((toggle) => toggle.setValue(this.plugin.settings.useObsidianFuzzyMatching).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.useObsidianFuzzyMatching = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Save most recent selections").setDesc("When enabled, display the ten most recent selections first by default.").addToggle((toggle) => toggle.setValue(this.plugin.settings.saveMostRecentSelections).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.saveMostRecentSelections = value;
      yield this.plugin.saveSettings();
    })));
  }
};
